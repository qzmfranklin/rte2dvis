\documentclass [8pt,letterpaper]{article}
\usepackage{xr}
\externaldocument[rte2dvis-derivation-]{derivation}
\usepackage{hyperref}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym,bm}
\usepackage{geometry}
\usepackage{graphics}
\usepackage{framed}
\usepackage{subfigure}
\usepackage{multirow}
%\usepackage{indentfirst}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{flafter}
% page style
%\geometry{textwidth=17cm,textheight=22cm}
%\usepackage{fancyhdr}
%\pagestyle{fancy}
% math
\usepackage{mathabx}
\usepackage{isomath}
\renewcommand{\vec}{\vectorsym}
\newcommand{\unitvec}[1]{\hat{\vec{#1}}}
\newcommand{\grad}{\nabla}
\renewcommand{\div}{\nabla\cdot}


\begin{document}
\title{Notes on How to Implement Eq.(6.3.10)}
%\author{\LaTeX\ by Zhongming Qu}
%\maketitle
%\tableofcontents
\newpage
\numberwithin{equation}{subsection}

test: reference to eq.\eqref{rte2dvis-derivation-eq:def-rte}.
\\
This notes focuses on the effective implementation of Eq.(6.3.10).
By default, refers to the derivation.pdf that comes with it.  
\\
You said that we should interpolate quantities containing
$\delta(\phi-\phi_{\vec{r}-\vec{r}^\prime})$,
e.g., $\psi_{sb}^I$ in Eq.(6.3.9),
with many "rays" prior to the code implementation.
By brute force, the CPU cost for each ray-tracing is $O(N_s)$ - already implemented.
For $N_s$ triangles and $M$ directions, the CPU cost is $O(N_s^2\times M)$.
Further plugging the interpolated quantity into the first line of Eq.(6.3.10) necessitates $O(N_s^3\times M)$ CPU time.
\\
Analytically, as shown in Eq.(6.3.10), the delta functions could be integrated.
The last line of Eq.(6.3.10) entails $O(N_s^3)$ CPU time.
In Eq.(6.3.12), all but the following quantities are already pre-computed:
\begin{align*}
	&
	%e^{-i m \phi_{\vec{r}_n-\vec{r}_{n^\prime}}}
	e^{- \tau(\vec{r}_n-\vec{r}_{n^\prime})}
	\\
	&
	f(
	\phi_{\vec{r}_n-\vec{r}_{n^\prime}}
	-
	\phi_{\vec{r}_{n^\prime}-\vec{r}_{n^\second}}
	)
	\\
	&
	f_{g^2}(\phi_{\vec{r}_n-\vec{r}_{n^\prime}}-\phi^I)
\end{align*}
The first term: $O(N_s^3)$ CPU and $O(N_s^2)$ memory. Ray tracing in $\tau$ added the extra $O(N_s)$.
\\
The second term: the angles inside are pre-computed.
\\
The third term: $O(N_s^2)$ CPU and memory.
\\
Of course, if the spatial part, i.e., calculation pertain to $N_s$ could be accelerated, the complexities decrease accordingly.
\\
As a first try, may I try implementing Eq.(6.3.10) by Eq.(6.3.12)?

\end{document}
